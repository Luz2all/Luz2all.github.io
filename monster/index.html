<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hero vs Monsters — Luz2all</title>
  <style>
    :root{--bg:#0f1724;--panel:#071027;--accent:#26a69a;--danger:#ef4444;--muted:#94a3b8;--tile:#0b1a2b;--wall:#092032;--text:#e6eef6}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#071025,#081430);color:var(--text)}
    .wrap{width:100%;max-width:1000px;padding:18px;box-sizing:border-box}
    header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;gap:12px}
    h1{margin:0;font-size:20px}
    .controls{display:flex;gap:8px;align-items:center}
    .btn{background:var(--accent);color:#042022;border:none;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
    .btn.secondary{background:transparent;color:var(--text);border:1px solid rgba(255,255,255,0.06)}
    .panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:12px;border-radius:10px;display:flex;gap:12px;align-items:center;box-shadow:0 6px 30px rgba(2,6,23,0.6)}
    .left{display:flex;gap:12px;align-items:center}
    .stats{display:flex;flex-direction:column;gap:6px;color:var(--muted);font-size:13px}
    .big{font-weight:700;color:var(--text)}
    .container{display:flex;gap:14px;flex-wrap:wrap}
    .canvas-wrap{background:var(--panel);padding:12px;border-radius:10px;flex:1 1 640px;min-width:320px;position:relative}
    canvas{display:block;border-radius:8px;background:linear-gradient(180deg,#071827,#0b2132);width:100%;height:auto}
    .right{width:260px;min-width:220px}
    .legend{font-size:13px;color:var(--muted);margin-top:8px}
    .hpbar{height:12px;background:rgba(255,255,255,0.06);border-radius:8px;overflow:hidden}
    .hpinner{height:100%;background:linear-gradient(90deg,var(--accent),#06b6a4);width:100%}
    .danger{background:linear-gradient(90deg,var(--danger),#fb7185)}
    .controls-row{display:flex;gap:8px;margin-top:8px}
    .hint{font-size:13px;color:var(--muted);margin-top:10px}
    .footer{margin-top:12px;color:var(--muted);font-size:13px}
    .mobile-controls{display:none;gap:8px;margin-top:10px}
    .mobile-controls button{width:56px;height:56px;border-radius:10px;font-size:18px;border:none;background:rgba(255,255,255,0.035);color:var(--text)}
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
    .panelBox{background:rgba(4,8,16,0.85);padding:16px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);pointer-events:auto}
    .small{font-size:13px;color:var(--muted)}
    @media (max-width:880px){.container{flex-direction:column}.right{width:100%}.mobile-controls{display:flex;justify-content:center}canvas{height:480px}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="left">
        <h1>Hero vs Monsters — Maze Clash</h1>
        <div class="panel">
          <div style="display:flex;flex-direction:column;margin-right:8px">
            <div class="muted" style="font-size:12px;color:var(--muted)">Hero HP</div>
            <div class="hpbar" style="width:140px">
              <div id="heroHpBar" class="hpinner" style="width:100%"></div>
            </div>
          </div>
          <div style="display:flex;flex-direction:column">
            <div class="muted" style="font-size:12px;color:var(--muted)">Monsters left</div>
            <div class="big" id="monstersLeft">0</div>
          </div>
        </div>
      </div>

      <div class="controls">
        <button class="btn" id="newGame">New Game</button>
        <button class="btn secondary" id="shuffle">Shuffle Monsters</button>
      </div>
    </header>

    <div class="container">
      <div class="canvas-wrap panel">
        <canvas id="gameCanvas" width="800" height="640"></canvas>
        <div class="hint">Move with arrow keys or WASD. Move into a monster tile to fight.<br>
          If monster HP &lt; hero HP you win and absorb their HP. If monster HP &ge; hero HP you lose (equal counts as losing) — toggle rule in options.</div>

        <div class="mobile-controls" id="mobileControls" aria-hidden="true" style="margin-top:12px">
          <button data-dir="up">↑</button>
          <div style="display:flex;gap:8px">
            <button data-dir="left">←</button>
            <button data-dir="down">↓</button>
            <button data-dir="right">→</button>
          </div>
        </div>

        <div id="overlay" class="overlay" style="display:none">
          <div class="panelBox" id="overlayBox">
            <div id="overlayText" class="big">You won!</div>
            <div class="small" id="overlaySub">Summary</div>
            <div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end">
              <button class="btn" id="overlayRestart">Restart</button>
              <button class="btn secondary" id="overlayClose">Close</button>
            </div>
          </div>
        </div>

      </div>

      <div class="right">
        <div class="panel" style="flex-direction:column">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div style="font-weight:700">Game Info</div>
            <div style="font-size:13px;color:var(--muted)">v2</div>
          </div>

          <div style="margin-top:8px" class="stats">
            <div>Hero HP: <span id="heroHpText" class="big">0</span></div>
            <div>Monsters defeated: <span id="defeated" class="big">0</span></div>
            <div>Moves: <span id="moves" class="big">0</span></div>
            <div>Best defeated: <span id="bestDefeated" class="big">0</span></div>
          </div>

          <div class="controls-row">
            <label style="color:var(--muted);font-size:13px">
              Maze size:
              <select id="sizeSelect" style="background:transparent;color:var(--text);border:none;padding:6px;border-radius:6px">
                <option value="15">Small (15x15)</option>
                <option value="25" selected>Medium (25x25)</option>
                <option value="35">Large (35x35)</option>
              </select>
            </label>
          </div>

          <div class="controls-row" style="margin-top:8px">
            <label style="color:var(--muted);font-size:13px">
              Monster density:
              <select id="densitySelect" style="background:transparent;color:var(--text);border:none;padding:6px;border-radius:6px">
                <option value="0.06">Light</option>
                <option value="0.10" selected>Normal</option>
                <option value="0.18">Dense</option>
              </select>
            </label>
          </div>

          <div style="margin-top:10px" class="legend">
            Legend:<br>
            <span style="display:inline-block;width:12px;height:12px;background:#7dd3fc;border-radius:2px;margin-right:6px"></span> Hero<br>
            <span style="display:inline-block;width:12px;height:12px;background:#f97316;border-radius:2px;margin-right:6px"></span> Monster (number = HP)<br>
            <span style="display:inline-block;width:12px;height:12px;background:var(--wall);border-radius:2px;margin-right:6px"></span> Wall / blocked
          </div>

          <div style="margin-top:12px;display:flex;gap:8px">
            <button class="btn" id="hintBtn">Show Shortest Path</button>
            <button class="btn secondary" id="saveBtn">Save Snapshot</button>
          </div>

          <div style="margin-top:12px;display:flex;gap:8px;align-items:center">
            <label class="small"><input type="checkbox" id="tieRule"> Hero wins on equal HP</label>
            <label class="small" style="margin-left:auto">Sound: <input type="range" id="vol" min="0" max="1" step="0.05" value="0.7"></label>
          </div>

        </div>

        <div class="footer">Published to <code>Luz2all.github.io/monster/</code>. Want extra features (moving monsters, leaderboard)? Ask and I’ll add them.</div>
      </div>
    </div>

  </div>

<script>
/* Enhanced Hero vs Monsters
  Enhancements:
   - Smooth hero movement animation
   - Confetti particle effect on defeating monsters
   - Sound effects via WebAudio (no external files)
   - Haptic feedback on mobile (vibrate on win/lose)
   - Persistent best defeated stored in localStorage
   - Option to change tie rule (hero wins if equal)
   - Overlays on game end with restart
   - Settings (volume)
*/

(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  let CANVAS_W = canvas.width, CANVAS_H = canvas.height;

  let CELL = 20;
  let GRID_W = 25, GRID_H = 25;
  let density = 0.10;
  let maze = [];
  let monsters = {};
  let hero = { r:1, c:1, hp: 12 };
  let monstersLeft = 0;
  let defeated = 0;
  let movesCount = 0;
  let gameOver = false;
  let showPath = false;
  let pathCells = [];

  // Animated hero position for smooth movement
  let heroPx = { x:0, y:0 };
  let heroMoving = false;

  // Particles (confetti)
  const particles = [];

  // UI
  const heroHpBar = document.getElementById('heroHpBar');
  const heroHpText = document.getElementById('heroHpText');
  const monstersLeftEl = document.getElementById('monstersLeft');
  const defeatedEl = document.getElementById('defeated');
  const movesEl = document.getElementById('moves');
  const bestDefeatedEl = document.getElementById('bestDefeated');
  const newGameBtn = document.getElementById('newGame');
  const shuffleBtn = document.getElementById('shuffle');
  const sizeSelect = document.getElementById('sizeSelect');
  const densitySelect = document.getElementById('densitySelect');
  const hintBtn = document.getElementById('hintBtn');
  const saveBtn = document.getElementById('saveBtn');
  const tieRuleCheckbox = document.getElementById('tieRule');
  const volControl = document.getElementById('vol');
  const overlay = document.getElementById('overlay');
  const overlayText = document.getElementById('overlayText');
  const overlaySub = document.getElementById('overlaySub');
  const overlayRestart = document.getElementById('overlayRestart');
  const overlayClose = document.getElementById('overlayClose');

  // Audio (simple beep-based effects)
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audioCtx = AudioCtx ? new AudioCtx() : null;
  function playTone(freq, time=0.12, type='sine', gain=0.12){
    if(!audioCtx || volControl.value == 0) return;
    const g = audioCtx.createGain();
    const o = audioCtx.createOscillator();
    o.type = type; o.frequency.value = freq;
    g.gain.value = gain * parseFloat(volControl.value);
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    o.stop(audioCtx.currentTime + time);
  }

  function vibrate(ms){ if(navigator.vibrate) navigator.vibrate(ms); }

  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)) }

  function generateMaze(w,h){
    const grid = Array.from({length:h}, ()=>Array.from({length:w}, ()=>0));
    function inBounds(r,c){ return r>0 && r<h-1 && c>0 && c<w-1 }
    const stack = [[1,1]]; grid[1][1]=1; const dirs=[[0,-2],[0,2],[-2,0],[2,0]];
    while(stack.length){
      const [r,c] = stack[stack.length-1];
      const neigh = [];
      for(const d of dirs){ const nr=r+d[0], nc=c+d[1]; if(inBounds(nr,nc) && grid[nr][nc]===0) neigh.push(d); }
      if(neigh.length===0) stack.pop(); else { const d = neigh[Math.floor(Math.random()*neigh.length)]; const nr=r+d[0], nc=c+d[1]; grid[r + d[0]/2][c + d[1]/2]=1; grid[nr][nc]=1; stack.push([nr,nc]); }
    }
    return grid;
  }

  function placeMonsters(){
    monsters = {}; monstersLeft=0;
    for(let r=1;r<GRID_H-1;r++) for(let c=1;c<GRID_W-1;c++){
      if(maze[r][c]===1 && !(r===hero.r && c===hero.c)){
        if(Math.random() < density){ const maxHp = Math.max(6, Math.floor(Math.min(GRID_W,GRID_H)/2) + 8); const hp = 1 + Math.floor(Math.random()*maxHp); monsters[`${r},${c}`] = {hp}; monstersLeft++; }
      }
    }
  }

  function startNewGame(){
    const size = parseInt(sizeSelect.value,10); GRID_W=size; GRID_H=size; if(GRID_W%2===0) GRID_W++; if(GRID_H%2===0) GRID_H++; density=parseFloat(densitySelect.value);
    const margin=24; const availableW = CANVAS_W - margin*2, availableH = CANVAS_H - margin*2; CELL = Math.max(10, Math.floor(Math.min(availableW/GRID_W, availableH/GRID_H)));
    maze = generateMaze(GRID_W, GRID_H);
    hero = { r:1, c:1, hp: Math.max(10, Math.floor(Math.random()*6) + 8) };
    if(maze[hero.r][hero.c] !== 1){ outer: for(let r=1;r<GRID_H-1;r++){ for(let c=1;c<GRID_W-1;c++){ if(maze[r][c]===1){ hero.r=r; hero.c=c; break outer; } } } }
    defeated = 0; movesCount = 0; gameOver=false; showPath=false; pathCells=[]; placeMonsters(); updateUI(); snapHero(); render();
  }

  function snapHero(){ const p = cellToPixel(hero.r, hero.c); heroPx.x = p.x; heroPx.y = p.y; }

  function updateUI(){ heroHpText.textContent = hero.hp; const cap = Math.max(20, hero.hp); const pct = clamp((hero.hp/cap)*100,5,100); heroHpBar.style.width = pct + '%'; if(hero.hp < 8) heroHpBar.style.background = 'linear-gradient(90deg,var(--danger),#fb7185)'; else heroHpBar.style.background = 'linear-gradient(90deg,var(--accent),#06b6a4)'; monstersLeftEl.textContent = monstersLeft; defeatedEl.textContent = defeated; movesEl.textContent = movesCount; bestDefeatedEl.textContent = localStorage.getItem('best_defeated') || '0'; }

  function cellToPixel(r,c){ const margin=24; const totalW=CELL*GRID_W; const totalH=CELL*GRID_H; const startX=(CANVAS_W-totalW)/2; const startY=(CANVAS_H-totalH)/2; const x = startX + c*CELL + CELL/2; const y = startY + r*CELL + CELL/2; return {x,y,startX,startY}; }

  function defeatMonsterAt(r,c){ const key=`${r},${c}`; const m = monsters[key]; if(!m) return; hero.hp += m.hp; delete monsters[key]; monstersLeft--; defeated++; spawnConfetti(cellToPixel(r,c).x, cellToPixel(r,c).y); playTone(880,0.08,'triangle',0.12); vibrate(40); flashCell(r,c,'#0ea5a4'); const best = parseInt(localStorage.getItem('best_defeated')||'0',10); if(defeated > best) localStorage.setItem('best_defeated', defeated); }

  function loseToMonsterAt(r,c){ playTone(120,0.5,'sawtooth',0.18); vibrate([80,40,80]); flashCell(r,c,'rgba(240,60,60,0.9)'); gameOver=true; showOverlay('Defeated', `You were defeated by a stronger monster (HP ${monsters[`${r},${c}`].hp}).`); }

  function tryMove(dr,dc){ if(gameOver) return; const nr=hero.r+dr, nc=hero.c+dc; if(nr<0||nc<0||nr>=GRID_H||nc>=GRID_W) return; if(maze[nr][nc]===0) return; // wall
    // animate movement
    const prev = {r:hero.r,c:hero.c}; hero.r=nr; hero.c=nc; movesCount++; updateUI(); heroMoving=true; const target = cellToPixel(nr,nc);
    // handle monsters after move completes (we'll schedule check)
    const key = `${nr},${nc}`;
    animateHeroTo(target.x, target.y, 120).then(()=>{
      heroMoving=false;
      if(monsters[key]){
        const m=monsters[key]; const tieHeroWins = tieRuleCheckbox.checked; if(m.hp < hero.hp || (tieHeroWins && m.hp === hero.hp)){ defeatMonsterAt(nr,nc); if(monstersLeft===0){ setTimeout(()=> showOverlay('Victory', 'All monsters defeated — you are the champion!'), 200); }} else { loseToMonsterAt(nr,nc); }
      }
      updateUI(); if(showPath) computeShortestPath();
    });
  }

  // Hero animation helper returns Promise
  function animateHeroTo(tx,ty,duration){ return new Promise(resolve=>{ const sx=heroPx.x, sy=heroPx.y; const start=performance.now(); function step(t){ const p = clamp((t-start)/duration,0,1); const ease = p<0.5?2*p*p: -1 + (4-2*p)*p; heroPx.x = sx + (tx-sx)*ease; heroPx.y = sy + (ty-sy)*ease; if(p<1) requestAnimationFrame(step); else { heroPx.x=tx; heroPx.y=ty; resolve(); } } requestAnimationFrame(step); }); }

  // Particles confetti
  function spawnConfetti(x,y){ for(let i=0;i<36;i++){ particles.push({x, y, vx:(Math.random()-0.5)*6, vy:(Math.random()-1.5)*6, life: 60 + Math.random()*30, col: `hsl(${Math.random()*60+180},80%,60%)`}); } }

  // Flash cells
  let flashes = []; function flashCell(r,c,color){ flashes.push({r,c,color,t:0}); }

  // Shortest path BFS
  function computeShortestPath(){ pathCells = []; const start=[hero.r,hero.c]; const q=[start]; const visited=new Set([`${start[0]},${start[1]}`]); const parent={}; let found=null; const dirs=[[1,0],[-1,0],[0,1],[0,-1]]; while(q.length){ const [r,c]=q.shift(); const key=`${r},${c}`; if(monsters[key]){ const m=monsters[key]; const tieHeroWins = tieRuleCheckbox.checked; if(m.hp < hero.hp || (tieHeroWins && m.hp===hero.hp)){ found=[r,c]; break; } } for(const d of dirs){ const nr=r+d[0], nc=c+d[1]; if(nr<0||nc<0||nr>=GRID_H||nc>=GRID_W) continue; const k2=`${nr},${nc}`; if(visited.has(k2)) continue; if(maze[nr][nc]===0) continue; visited.add(k2); parent[k2]=key; q.push([nr,nc]); } }
    if(found){ let cur = `${found[0]},${found[1]}`; while(cur){ const parts = cur.split(',').map(Number); pathCells.push(parts); cur = parent[cur]; } pathCells.reverse(); }
  }

  // Overlay
  function showOverlay(title, sub){ overlayText.textContent = title; overlaySub.textContent = sub; overlay.style.display='flex'; }
  function hideOverlay(){ overlay.style.display='none'; }

  overlayRestart.addEventListener('click', ()=>{ hideOverlay(); startNewGame(); });
  overlayClose.addEventListener('click', ()=>{ hideOverlay(); });

  // Input
  let lastKeyTime=0; window.addEventListener('keydown',(e)=>{ const now=Date.now(); if(now-lastKeyTime<90) return; lastKeyTime=now; if(gameOver) return; switch(e.key){ case 'ArrowUp': tryMove(-1,0); break; case 'ArrowDown': tryMove(1,0); break; case 'ArrowLeft': tryMove(0,-1); break; case 'ArrowRight': tryMove(0,1); break; case 'w': case 'W': tryMove(-1,0); break; case 's': case 'S': tryMove(1,0); break; case 'a': case 'A': tryMove(0,-1); break; case 'd': case 'D': tryMove(0,1); break; } });

  // Mobile controls
  document.getElementById('mobileControls').querySelectorAll('button').forEach(btn=>{ btn.addEventListener('touchstart',ev=>{ ev.preventDefault(); handleDir(btn.getAttribute('data-dir')); },{passive:false}); btn.addEventListener('mousedown',()=>handleDir(btn.getAttribute('data-dir'))); }); function handleDir(dir){ if(gameOver) return; switch(dir){ case 'up': tryMove(-1,0); break; case 'down': tryMove(1,0); break; case 'left': tryMove(0,-1); break; case 'right': tryMove(0,1); break; } }

  // Touch swipe
  let touchStart=null; canvas.addEventListener('touchstart', e=>{ if(e.touches.length===1){ const t=e.touches[0]; touchStart={x:t.clientX,y:t.clientY,time:Date.now()}; } },{passive:true}); canvas.addEventListener('touchend', e=>{ if(touchStart && e.changedTouches[0]){ const t=e.changedTouches[0]; const dx=t.clientX-touchStart.x, dy=t.clientY-touchStart.y, absX=Math.abs(dx), absY=Math.abs(dy); if(Math.max(absX,absY)>20){ if(absX>absY){ if(dx>0) tryMove(0,1); else tryMove(0,-1); } else { if(dy>0) tryMove(1,0); else tryMove(-1,0); } } touchStart=null; } },{passive:true});

  // Buttons
  newGameBtn.addEventListener('click', ()=> startNewGame()); shuffleBtn.addEventListener('click', ()=>{ placeMonsters(); updateUI(); render(); playTone(660,0.08,'sine',0.12); }); sizeSelect.addEventListener('change', ()=> startNewGame()); densitySelect.addEventListener('change', ()=> startNewGame()); hintBtn.addEventListener('click', ()=>{ showPath = !showPath; if(showPath) computeShortestPath(); hintBtn.textContent = showPath ? 'Hide Path' : 'Show Shortest Path'; render(); }); saveBtn.addEventListener('click', ()=>{ const url = canvas.toDataURL(); const w = window.open(''); w.document.write(`<img src="${url}" alt="Snapshot">`); });

  volControl.addEventListener('input', ()=>{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); });

  // Canvas resize
  function resizeCanvas(){ const rect = canvas.getBoundingClientRect(); CANVAS_W = Math.max(480, Math.floor(rect.width)); CANVAS_H = Math.max(360, Math.floor(rect.height)); const ratio = window.devicePixelRatio || 1; canvas.width = CANVAS_W * ratio; canvas.height = CANVAS_H * ratio; canvas.style.width = CANVAS_W + 'px'; canvas.style.height = CANVAS_H + 'px'; ctx.setTransform(ratio,0,0,ratio,0,0); if(GRID_W && GRID_H){ const margin=24; const availableW = CANVAS_W - margin*2, availableH = CANVAS_H - margin*2; CELL = Math.max(10, Math.floor(Math.min(availableW/GRID_W, availableH/GRID_H))); } render(); }
  window.addEventListener('resize', resizeCanvas);

  // Render
  function render(){ ctx.clearRect(0,0,CANVAS_W,CANVAS_H); ctx.fillStyle='#041321'; ctx.fillRect(0,0,CANVAS_W,CANVAS_H); const totalW=CELL*GRID_W, totalH=CELL*GRID_H; const startX=(CANVAS_W-totalW)/2, startY=(CANVAS_H-totalH)/2; for(let r=0;r<GRID_H;r++) for(let c=0;c<GRID_W;c++){ const x=startX+c*CELL, y=startY+r*CELL; if(maze[r][c]===0){ ctx.fillStyle='rgba(255,255,255,0.03)'; ctx.fillRect(x,y,CELL,CELL); } else { ctx.fillStyle='#06202d'; ctx.fillRect(x,y,CELL,CELL); ctx.strokeStyle='rgba(255,255,255,0.02)'; ctx.strokeRect(x+0.5,y+0.5,CELL-1,CELL-1); } }
    if(showPath && pathCells.length){ ctx.fillStyle='rgba(45,212,191,0.08)'; for(const [r,c] of pathCells){ const x=startX+c*CELL, y=startY+r*CELL; ctx.fillRect(x+2,y+2,CELL-4,CELL-4); } }
    ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font=`${Math.max(10,CELL*0.4)}px bold sans-serif`;
    for(const key in monsters){ const [r,c]=key.split(',').map(Number); const {x,y}=cellToPixel(r,c); ctx.beginPath(); ctx.fillStyle='#fb923c'; ctx.arc(x,y,CELL*0.36,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#041321'; ctx.fillText(String(monsters[key].hp), x, y); }
    for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; ctx.fillStyle=p.col; ctx.fillRect(p.x, p.y, 4, 6); p.x += p.vx; p.y += p.vy; p.vy += 0.18; p.life--; if(p.life<=0) particles.splice(i,1); }
    for(let i=flashes.length-1;i>=0;i--){ const f=flashes[i]; f.t += 1/60; const alpha = Math.max(0,1 - f.t/0.6); const {x,y} = cellToPixel(f.r,f.c); ctx.globalAlpha = alpha; ctx.fillStyle = f.color; ctx.fillRect(x - CELL/2, y - CELL/2, CELL, CELL); ctx.globalAlpha = 1; if(f.t > 0.6) flashes.splice(i,1); }
    const heroPos = { x: heroPx.x, y: heroPx.y };
    ctx.save(); ctx.beginPath(); ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.ellipse(heroPos.x, heroPos.y + CELL*0.36, CELL*0.5, CELL*0.18, 0,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.fillStyle='#7dd3fc'; ctx.arc(heroPos.x, heroPos.y, CELL*0.38,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#04202a'; ctx.font=`${Math.max(12,CELL*0.4)}px bold sans-serif`; ctx.fillText('H', heroPos.x, heroPos.y+1); ctx.restore(); ctx.strokeStyle='rgba(255,255,255,0.03)'; ctx.strokeRect(startX+0.5,startY+0.5,totalW-1,totalH-1); }

  // Spawn initial hero pixel pos
  function snapHeroPos(){ const p = cellToPixel(hero.r,hero.c); heroPx.x = p.x; heroPx.y = p.y; }

  // Game end overlay helper
  function onWinSummary(){ const best = parseInt(localStorage.getItem('best_defeated')||'0',10); overlayText.textContent = 'Victory!'; overlaySub.textContent = `Monsters defeated: ${defeated}. Best: ${best}.`; showOverlay(overlayText.textContent, overlaySub.textContent); }

  // Play loop
  function loop(){ // update particles simple physics handled in render
    render(); requestAnimationFrame(loop); }

  // init
  resizeCanvas(); startNewGame(); snapHeroPos(); requestAnimationFrame(loop);

})();
</script>

</body>
</html>
